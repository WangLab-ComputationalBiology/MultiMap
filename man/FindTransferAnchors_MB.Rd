% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/batchWeight.R
\name{FindTransferAnchors_MB}
\alias{FindTransferAnchors_MB}
\title{Find transfer anchors list}
\usage{
FindTransferAnchors_MB(
  reference,
  query,
  batch = "batch",
  normalization.method = "LogNormalize",
  recompute.residuals = TRUE,
  reference.assay = NULL,
  reference.neighbors = NULL,
  query.assay = NULL,
  reduction = "pcaproject",
  reference.reduction = NULL,
  project.query = FALSE,
  features = NULL,
  scale = TRUE,
  npcs = 30,
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = 200,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0,
  approx.pca = TRUE,
  mapping.score.k = NULL,
  verbose = TRUE
)
}
\arguments{
\item{reference}{\code{\link{Seurat}} object to use as the reference}

\item{query}{\code{\link{Seurat}} object to use as the query}

\item{batch}{batch column in meta.data of Seurat object}

\item{normalization.method}{Name of normalization method used: LogNormalize
or SCT.}

\item{recompute.residuals}{If using SCT as a normalization method, compute
query Pearson residuals using the reference SCT model parameters.}

\item{reference.assay}{Name of the Assay to use from reference}

\item{reference.neighbors}{Name of the Neighbor to use from the reference.
Optionally enables reuse of precomputed neighbors.}

\item{query.assay}{Name of the Assay to use from query}

\item{reduction}{Dimensional reduction to perform when finding anchors.
Options are:
\itemize{
\item{pcaproject: Project the PCA from the reference onto the query. We
recommend using PCA when reference and query datasets are from scRNA-seq}
\item{lsiproject: Project the LSI from the reference onto the query. We
recommend using LSI when reference and query datasets are from scATAC-seq.
This requires that LSI has been computed for the reference dataset, and the
same features (eg, peaks or genome bins) are present in both the reference
and query. See \code{\link[Signac]{RunTFIDF}} and
\code{\link[Signac]{RunSVD}}}
\item{rpca: Project the PCA from the reference onto the query, and the PCA
from the query onto the reference (reciprocal PCA projection).}
\item{cca: Run a CCA on the reference and query }
}}

\item{reference.reduction}{Name of dimensional reduction to use from the
reference if running the pcaproject workflow. Optionally enables reuse of
precomputed reference dimensional reduction. If NULL (default), use a PCA
computed on the reference object.}

\item{project.query}{Project the PCA from the query dataset onto the
reference. Use only in rare cases where the query dataset has a much larger
cell number, but the reference dataset has a unique assay for transfer. In
this case, the default features will be set to the variable features of the
query object that are alos present in the reference.}

\item{features}{Features to use for dimensional reduction. If not specified,
set as variable features of the reference object which are also present in
the query.}

\item{scale}{Scale query data.}

\item{npcs}{Number of PCs to compute on reference if reference.reduction is
not provided.}

\item{l2.norm}{Perform L2 normalization on the cell embeddings after
dimensional reduction}

\item{dims}{Which dimensions to use from the reduction to specify the
neighbor search space}

\item{k.anchor}{How many neighbors (k) to use when finding anchors}

\item{k.filter}{How many neighbors (k) to use when filtering anchors. Set to
NA to turn off filtering.}

\item{k.score}{How many neighbors (k) to use when scoring anchors}

\item{max.features}{The maximum number of features to use when specifying the
neighborhood search space in the anchor filtering}

\item{nn.method}{Method for nearest neighbor finding. Options include: rann,
annoy}

\item{n.trees}{More trees gives higher precision when using annoy approximate
nearest neighbor search}

\item{eps}{Error bound on the neighbor finding algorithm (from
\code{\link{RANN}} or \code{\link{RcppAnnoy}})}

\item{approx.pca}{Use truncated singular value decomposition to approximate
PCA}

\item{mapping.score.k}{Compute and store nearest k query neighbors in the
AnchorSet object that is returned. You can optionally set this if you plan
on computing the mapping score and want to enable reuse of some downstream
neighbor calculations to make the mapping score function more efficient.}

\item{verbose}{Print progress bars and output}
}
\value{
Returns an \code{AnchorSet} object list.
}
\description{
Find a set of anchors between each reference batch and query object. These
anchors can later be used to transfer data from the reference to
query object using the \code{\link{TransferData}} object.
}
